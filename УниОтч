
&НаСервере
Процедура ВывестиУровень(стру, ур, ма_стр, ур_зн, ур_рекв, Рекурсия)
	
	фл_последний_плюсом = Ложь;
	колич_ур = стру.КоличествоУровнейБезПоследнегоПлюса;
	
	Если ур = 1 И колич_ур > 1 Тогда
		о = стру.Макет.ПолучитьОбласть("Группа1");
	ИначеЕсли ур = 2 и колич_ур > 2 Тогда
		о = стру.Макет.ПолучитьОбласть("Группа2");
	ИначеЕсли ур < колич_ур Тогда
		о = стру.Макет.ПолучитьОбласть("Группа3");
	ИначеЕсли ур = колич_ур Тогда
		о = стру.Макет.ПолучитьОбласть("Строка");
	Иначе
		о = стру.Макет.ПолучитьОбласть("Доки");
		фл_последний_плюсом = Истина;
	КонецЕсли;
	
	преф = "";
	Для н = 1 по ур-1 Цикл
		преф = преф + "   ";
	КонецЦикла;
	Если ЗначениеЗаполнено(ур_зн) Тогда
		Попытка
			ур_назв = преф + стру.Контекст.Название(ур_зн, ур_рекв);
		Исключение
			ур_назв = преф + Строка(ур_зн);
		КонецПопытки;
	Иначе
		ур_назв = преф + "<Пустое "+ур_рекв+">";
	КонецЕсли;
	
	рс = ПосчитатьИтогПоСтрокам(ма_стр, стру.ДетализацияИтоги);
	
	Если НЕ фл_последний_плюсом Тогда
		стру.НомПП = стру.НомПП + 1;
		о.Параметры.НомПП = стру.НомПП;
	КонецЕсли;
	
	стру.Контекст.ЗаполнитьОбластьСтроки(о, рс, ур_рекв, ур_зн, ур_назв, Рекурсия);
	
	гр = ?(фл_последний_плюсом, 1, 0);
	стру.ТабДок.Вывести(о, гр, , Ложь);
	
КонецПроцедуры

&НаСервере
Процедура РекурсивноеФормированиеТабличногоДокумента(стру, ур, ма_стр, ур_зн, ур_рекв, Рекурсия)
	// Данные,Детализация,ПлюсПоследний,Макет,ТабДок,НомПП
	
	// уровень == 0 - уровень без вывода в таблицу и без реквизита уровня.
	//  Только группирование по значениям первого уровня, и последующий вызов первого уровня
	
	Если ур > 0 Тогда
		ВывестиУровень(стру, ур, ма_стр, ур_зн, ур_рекв, Рекурсия);
	Иначе
		ма_стр = стру.Данные;
	КонецЕсли;
	
	Если ур >= стру.Детализация.Количество() Тогда
		возврат;
	КонецЕсли;
	
	// расчет следующего уровня и затем вызов
	
	рекв = стру.Детализация.Получить(ур);
	Если рекв <> "ИТОГО" Тогда
		инд = стру.Данные.Колонки.Индекс(стру.Данные.Колонки.Найти(рекв));
	КонецЕсли;
	
	т_зн = новый ТаблицаЗначений;
	т_зн.Колонки.Добавить("Значение");
	т_зн.Колонки.Добавить("Строки");
	т_зн.Колонки.Добавить("ЗначениеСортировки");
	
	Для каждого сс из ма_стр цикл
		Если рекв = "ИТОГО" Тогда
			зн = "ИТОГО";
		Иначе
			зн = сс.Получить(инд);
		КонецЕсли;
		
		Попытка
			фл_пропустить = стру.Контекст.ПропуститьСтроку(стру, сс, ур+1, зн, рекв);
		Исключение
			фл_пропустить = Ложь;
		КонецПопытки;
		
		Если фл_пропустить тогда
			продолжить;
		КонецЕсли;
		
		сс_зн = т_зн.Найти(зн, "Значение");
		Если сс_зн = Неопределено Тогда
			сс_зн = т_зн.Добавить();
			сс_зн.Значение = зн;
			
			Попытка
				сс_зн.ЗначениеСортировки = стру.Контекст.ЗначениеСортировки(зн, рекв);
			Исключение
				сс_зн.ЗначениеСортировки = зн;
			КонецПопытки;
			
			сс_зн.Строки = новый Массив;
		КонецЕсли;
		
		сс_зн.Строки.Добавить(сс);
	КонецЦикла;
	т_зн.Сортировать("ЗначениеСортировки");
	
	// рекурсивный вызов для каждого значения уровня
	Для каждого сс из т_зн Цикл
		Рекурсия.Вставить(рекв, сс.Значение);
		РекурсивноеФормированиеТабличногоДокумента(стру, ур+1, сс.Строки, сс.Значение, рекв, Рекурсия);
	КонецЦикла;
	Рекурсия.Удалить(рекв);
	
КонецПроцедуры

&НаСервере
Процедура СформироватьТаблицу(стру) Экспорт
	
	
	Если стру.ДелатьДетализациюИтого Тогда
		стру.Детализация.Вставить(0, "ИТОГО");
	КонецЕсли;
	
	стру.Вставить("НомПП", 0);
	
	колич_ур = стру.Детализация.Количество();
	стру.Вставить("КоличествоУровней", колич_ур);
	ф = Ложь;
	Если стру.Свойство("ПлюсПоследний", ф) и ф Тогда
		колич_ур = колич_ур - 1;
	КонецЕсли;
	
	стру.Вставить("КоличествоУровнейБезПоследнегоПлюса", колич_ур);
	
	Рекурсия = новый Структура;
	
	стру.ТабДок.НачатьАвтогруппировкуСтрок();
	РекурсивноеФормированиеТабличногоДокумента(стру, 0, 0, 0, "", Рекурсия);
	стру.ТабДок.ЗакончитьАвтогруппировкуСтрок();
КонецПроцедуры

&НаСервере
Функция   ИтогПоСтрокам_один_реквизит(ма_стр, рекв, ЕстьЦифры = Ложь, Тп = "сумма")
	
	перв = Истина;
	рез = 0;
	тп = НРег(тп);
	инд = -1;
	
	Для каждого сс из ма_стр цикл
		
		Если инд < 0 Тогда
			т = сс.Владелец();
			инд = т.Колонки.Индекс(т.Колонки.Найти(рекв));
		КонецЕсли;
		
		ч = сс.Получить(инд);
		
		Если тп = "сумма" Тогда
			
			Если ч = Неопределено или ч = null тогда
				ч = 0;
			КонецЕсли;
			
			Если ТипЗнч(ч) <> Тип("Число") Тогда
				сообщить("Рекв: "+рекв+", не число: "+ч);
			Иначе
				рез = рез + ч;
			КонецЕсли;
			
			Если ч <> 0 Тогда
				ЕстьЦифры = Истина;
			КонецЕсли;
			
		ИначеЕсли тп = "равные" Тогда
			
			Если перв Тогда
				рез = ч;
				перв = ложь;
			ИначеЕсли рез <> ч Тогда
				рез = "~~~";
				прервать;
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;
	возврат рез;
КонецФункции

&НаСервере
Функция   ПосчитатьИтогПоСтрокам(ма_стр, ма_рекв, ЕстьЦифры = Ложь)
	
	ма = РазделитьРеквизиты(ма_рекв);
	
	стру = новый Структура;
	
	Для каждого рекв из ма цикл
		
		рекв_уст = рекв;
		тп = "сумма";
		п = СтрНайти(рекв,":");
		Если п > 0 Тогда
			тп = Лев(рекв, п-1);
			рекв = Сред(рекв, п+1);
			рекв_уст = тп + "_" + рекв;
		КонецЕсли;
		
		ец = Ложь;
		су = ИтогПоСтрокам_один_реквизит(ма_стр, рекв, ец, тп);
		
		стру.Вставить(рекв_уст, су);
		стру.Вставить(рекв_уст+"_ЕстьЦифры", ец);
		
		ЕстьЦифры = ЕстьЦифры ИЛИ ец;
	КонецЦикла;
	
	возврат стру;
КонецФункции

Функция   ВыбратьПомеченные(сп) Экспорт
	ма = новый Массив;
	Для каждого эл из сп цикл
		Если эл.Пометка Тогда
			ма.Добавить(эл.Значение);
		КонецЕсли;
	КонецЦикла;
	возврат ма;
КонецФункции

Процедура СделатьДетализацию(СписСГалочками, Множество) Экспорт
	
	ма = РазделитьРеквизиты(Множество);
	
	Для каждого с из ма Цикл
		Если СписСГалочками.НайтиПоЗначению(с) = Неопределено Тогда
			СписСГалочками.Добавить(с);
		КонецЕсли;
	КонецЦикла;
	
	ма_уд = новый Массив;
	Для каждого эл из СписСГалочками Цикл
		Если ма.Найти(эл.Значение) = Неопределено Тогда
			ма_уд.Добавить(эл);
		Иначе
			ма.Удалить(ма.найти(эл.Значение));
		КонецЕсли;
	КонецЦикла;
	
	Для каждого эл из ма_уд цикл
		СписСГалочками.Удалить(эл);
	КонецЦикла;
	
КонецПроцедуры

Функция   СравнитьСписки(сп, ма)
	
	Если сп.Количество() <> ма.Количество() Тогда
		возврат Ложь;
	КонецЕсли;
	
	Для н = 0 по ма.Количество()-1 цикл
		Если сп.Получить(н).Значение <> ма.Получить(н) Тогда
			возврат Ложь;
		КонецЕсли;
	КонецЦикла;
	
	возврат Истина;
КонецФункции

