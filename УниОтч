
Функция   лямбда_НазваниеДляОтчета(стру, ур_зн, ур_рекв)
	
	Если НЕ ЗначениеЗаполнено(ур_зн) Тогда
		возврат "<Пустое "+ур_рекв+">";
	КонецЕсли;
	
	Если НЕ стру.Свойство("ОтсутствуетМетод_Название") Тогда
		Попытка
			возврат стру.Контекст.НазваниеДляОтчета(ур_зн, ур_рекв);
		Исключение
			стру.Вставить("ОтсутствуетМетод_Название", Истина);
		КонецПопытки;
	КонецЕсли;
	
	возврат Строка(ур_зн);
КонецФункции

Функция   лямбда_ПропуститьСтроку(стру, с_данные, ур_индекс, ур_зн)
	
	Если НЕ стру.Свойство("ОтсутствуетМетод_ПропуститьСтроку") Тогда
		
		ур_рекв = стру.Детализация.Получить(ур_индекс);
		
		Попытка
			возврат стру.Контекст.ПропуститьСтроку(стру, с_данные, ур_индекс, ур_зн);
		Исключение
			стру.Вставить("ОтсутствуетМетод_ПропуститьСтроку", Истина);
		КонецПопытки;
		
	КонецЕсли;
	
	возврат Ложь;
КонецФункции

Функция   лямбда_ЗначениеСортировки(стру, ур_зн, ур_рекв)
	
	Если НЕ стру.Свойство("ОтсутствуетМетод_ЗначениеСортировки") Тогда
		Попытка
			возврат стру.Контекст.ЗначениеСортировки(ур_зн, ур_рекв);
		Исключение
			стру.Вставить("ОтсутствуетМетод_ЗначениеСортировки", Истина);
		КонецПопытки;
	КонецЕсли;
	
	возврат ур_зн;
КонецФункции

Процедура лямбда_ЗаполнитьОбластьСтроки(стру, обл, стру_итоги, ур_рекв, ур_зн, ур_назв, Рекурсия)
	
	Нету = Истина;
	
	Если НЕ стру.Свойство("ОтсутсвуетМетод_ЗаполнитьОбластьСтроки") Тогда
		Попытка
			стру.Контекст.ЗаполнитьОбластьСтроки(обл, стру_итоги, ур_рекв, ур_зн, ур_назв, Рекурсия);
			Нету = Ложь;
		Исключение
			стру.Вставить("ОтсутсвуетМетод_ЗаполнитьОбластьСтроки", Истина);
		КонецПопытки;
	КонецЕсли;
	
	Если Нету Тогда
		обл.Параметры.Заполнить(Рекурсия);
		обл.Параметры.Заполнить(стру_итоги);
		обл.Параметры.Заполнить(новый Структура("Значение,Название", ур_зн, ур_назв));
	КонецЕсли;
	
КонецПроцедуры

&НаСервере
Процедура ВывестиУровень(стру, ур_индекс, ма_данные, Рекурсия)
	
	// ур_индекс: 0..КоличествоУровней-1
	ур_рекв = стру.Детализация.Получить(ур_индекс);
	ур_зн = Рекурсия[ур_рекв];
	
	фл_последний_свернут = Ложь;
	колич_ур = стру.КоличествоУровнейБезПоследнегоПлюса;
	
	Если ур_индекс = 0 И колич_ур > 1 Тогда
		о = стру.Макет.ПолучитьОбласть("Группа1");
	ИначеЕсли ур_индекс = 1 и колич_ур > 2 Тогда
		о = стру.Макет.ПолучитьОбласть("Группа2");
	ИначеЕсли ур_индекс+1 < колич_ур Тогда
		о = стру.Макет.ПолучитьОбласть("Группа3");
	ИначеЕсли ур_индекс+1 = колич_ур Тогда
		о = стру.Макет.ПолучитьОбласть("Строка");
	Иначе
		о = стру.Макет.ПолучитьОбласть("Доки");
		фл_последний_свернут = Истина;
	КонецЕсли;
	
	преф = "";
	Для н = 1 по ур_индекс Цикл
		преф = преф + "   ";
	КонецЦикла;
	
	ур_назв = преф + лямбда_НазваниеДляОтчета(стру, ур_зн, ур_рекв);
	
	стру_итоги = ПосчитатьИтогПоСтрокам(стру, ма_данные);
	
	Если НЕ фл_последний_свернут Тогда
		НомПП = стру.НомПП + 1;
		стру.НомПП = НомПП;
		о.Параметры.Заполнить(новый Структура("НомПП", НомПП));
	КонецЕсли;
	
	лямбда_ЗаполнитьОбластьСтроки(стру, о, стру_итоги, ур_рекв, ур_зн, ур_назв, Рекурсия);
	
	стру.ТабДок.Вывести(о, ур_индекс, , НЕ фл_последний_свернут);
	
КонецПроцедуры

&НаСервере
Процедура РекурсивноеФормированиеТабличногоДокумента(стру, ур_индекс, ма_данные, Рекурсия)
	// ур_индекс: 0..КоличествоУровней-1
	
	ур_рекв = стру.Детализация.Получить(ур_индекс);
	Если ур_рекв <> "ИТОГО" Тогда
		инд_колонки = стру.Данные.Колонки.Индекс(стру.Данные.Колонки.Найти(ур_рекв));
	КонецЕсли;
	
	т_группы = новый ТаблицаЗначений;
	т_группы.Колонки.Добавить("Значение");
	т_группы.Колонки.Добавить("Строки");
	т_группы.Колонки.Добавить("ЗначениеСортировки");
	т_группы.Индексы.Добавить("Значение");
	
	Для каждого с_данные из ма_данные цикл
		Если ур_рекв = "ИТОГО" Тогда
			ур_зн = "ИТОГО";
		Иначе
			ур_зн = с_данные.Получить(инд_колонки);
		КонецЕсли;
		
		фл_пропустить = лямбда_ПропуститьСтроку(стру, с_данные, ур_индекс, ур_зн);
		
		Если фл_пропустить тогда
			продолжить;
		КонецЕсли;
		
		с_группы = т_группы.Найти(ур_зн, "Значение");
		Если с_группы = Неопределено Тогда
			с_группы = т_группы.Добавить();
			с_группы.Значение = ур_зн;
			с_группы.ЗначениеСортировки = лямбда_ЗначениеСортировки(стру, ур_зн, ур_рекв);
			с_группы.Строки = новый Массив;
		КонецЕсли;
		
		с_группы.Строки.Добавить(с_данные);
	КонецЦикла;
	т_группы.Сортировать("ЗначениеСортировки");
	
	// рекурсивный вызов для каждого значения уровня
	
	количество_уровней = стру.Детализация.Количество();
	
	Для каждого с_группы из т_группы Цикл
		Рекурсия.Вставить(ур_рекв, с_группы.Значение);
		
		ВывестиУровень(стру, ур_индекс, с_группы.Строки, Рекурсия);
		
		Если ур_индекс+1 < количество_уровней Тогда
			РекурсивноеФормированиеТабличногоДокумента(стру, ур_индекс+1, с_группы.Строки, Рекурсия);
		КонецЕсли;
	КонецЦикла;
	Рекурсия.Удалить(ур_рекв);
	
КонецПроцедуры

&НаСервере
Процедура СформироватьТаблицу(стру) Экспорт
	
	Если стру.ДелатьДетализациюИтого Тогда
		стру.Детализация.Вставить(0, "ИТОГО");
	КонецЕсли;
	
	стру.Вставить("НомПП", 0);
	
	колич_ур = стру.Детализация.Количество();
	стру.Вставить("КоличествоУровней", колич_ур);
	ф = Ложь;
	Если стру.Свойство("ПлюсПоследний", ф) и ф = Истина Тогда
		колич_ур = колич_ур - 1;
	КонецЕсли;
	
	стру.Вставить("КоличествоУровнейБезПоследнегоПлюса", колич_ур);
	
	Рекурсия = новый Структура;
	
	стру.ТабДок.НачатьАвтогруппировкуСтрок();
	РекурсивноеФормированиеТабличногоДокумента(стру, 0, стру.Данные, Рекурсия);
	стру.ТабДок.ЗакончитьАвтогруппировкуСтрок();
КонецПроцедуры

&НаСервере
Функция   ИтогПоСтрокам_один_реквизит(ма_данные, рекв, ЕстьЦифры = Ложь, Тп = "сумма")
	
	перв = Истина;
	рез = 0;
	тп = НРег(тп);
	инд_колонки = -1;
	
	Для каждого с_данные из ма_данные цикл
		
		Если инд_колонки < 0 Тогда
			т = с_данные.Владелец();
			инд_колонки = т.Колонки.Индекс(т.Колонки.Найти(рекв));
		КонецЕсли;
		
		ч = с_данные.Получить(инд_колонки);
		
		Если тп = "сумма" Тогда
			
			Если ч = Неопределено или ч = null тогда
				ч = 0;
			КонецЕсли;
			
			Если ТипЗнч(ч) <> Тип("Число") Тогда
				сообщить("Рекв: "+рекв+", не число: "+ч);
			Иначе
				рез = рез + ч;
			КонецЕсли;
			
			Если ч <> 0 Тогда
				ЕстьЦифры = Истина;
			КонецЕсли;
			
		ИначеЕсли тп = "равные" Тогда
			
			Если перв Тогда
				рез = ч;
				перв = ложь;
			ИначеЕсли рез <> ч Тогда
				рез = "~~~";
				прервать;
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;
	возврат рез;
КонецФункции

&НаСервере
Функция   ПосчитатьИтогПоСтрокам(стру, ма_данные, ЕстьЦифры = Ложь)
	// ЕстьЦифры - возвращаемый признак, что в колонки были цифры отличные от нуля
	//  Даже если итог плюс на минус равен нулю, то здесь будет истина, если были
	//  отличные от нуля
	
	ма_рекв = Неопределено;
	Если НЕ стру.Свойство("Обработанное_ДетализацияИтоги", ма_рекв) Тогда
		ма_рекв = РазделитьРеквизиты(стру.ДетализацияИтоги);
		стру.Вставить("Обработанное_ДетализацияИтоги", ма_рекв);
	КонецЕсли;
	
	стру_рез = новый Структура;
	
	Для каждого рекв из ма_рекв цикл
		
		рекв_уст = рекв;
		тп = "сумма";
		п = СтрНайти(рекв,":");
		Если п > 0 Тогда
			тп = Лев(рекв, п-1);
			рекв = Сред(рекв, п+1);
			рекв_уст = тп + "_" + рекв;
		КонецЕсли;
		
		ЕстьЦифры_здесь = Ложь;
		су = ИтогПоСтрокам_один_реквизит(ма_данные, рекв, ЕстьЦифры_здесь, тп);
		
		стру_рез.Вставить(рекв_уст, су);
		стру_рез.Вставить(рекв_уст+"_ЕстьЦифры", ЕстьЦифры_здесь);
		
		ЕстьЦифры = ЕстьЦифры ИЛИ ЕстьЦифры_здесь;
	КонецЦикла;
	
	возврат стру_рез;
КонецФункции

Функция   ВыбратьПомеченные(сп) Экспорт
	ма = новый Массив;
	Для каждого эл из сп цикл
		Если эл.Пометка Тогда
			ма.Добавить(эл.Значение);
		КонецЕсли;
	КонецЦикла;
	возврат ма;
КонецФункции

Процедура СделатьДетализацию(СписСГалочками, Множество) Экспорт
	
	ма = РазделитьРеквизиты(Множество);
	
	Для каждого с из ма Цикл
		Если СписСГалочками.НайтиПоЗначению(с) = Неопределено Тогда
			СписСГалочками.Добавить(с);
		КонецЕсли;
	КонецЦикла;
	
	ма_уд = новый Массив;
	Для каждого эл из СписСГалочками Цикл
		Если ма.Найти(эл.Значение) = Неопределено Тогда
			ма_уд.Добавить(эл);
		Иначе
			ма.Удалить(ма.найти(эл.Значение));
		КонецЕсли;
	КонецЦикла;
	
	Для каждого эл из ма_уд цикл
		СписСГалочками.Удалить(эл);
	КонецЦикла;
	
КонецПроцедуры

Функция   СравнитьСписки(сп, ма) Экспорт
	
	Если сп.Количество() <> ма.Количество() Тогда
		возврат Ложь;
	КонецЕсли;
	
	Для н = 0 по ма.Количество()-1 цикл
		Если сп.Получить(н).Значение <> ма.Получить(н) Тогда
			возврат Ложь;
		КонецЕсли;
	КонецЦикла;
	
	возврат Истина;
КонецФункции

&НаКлиенте
Процедура СдвигПериода(НачПериода, КонПериода, знк) Экспорт
	Если не ЗначениеЗаполнено(НачПериода) и не ЗначениеЗаполнено(КонПериода) Тогда
		НачПериода = НачалоМесяца(ТекущаяДата());
		КонПериода = НачалоДня(КонецМесяца(НачПериода));
	ИначеЕсли не ЗначениеЗаполнено(НачПериода) или не ЗначениеЗаполнено(КонПериода) Тогда
		дд = НеПуст(НачПериода, КонПериода);
		НачПериода = НачалоМесяца(ДобавитьМесяц(дд, знк));
		КонПериода = НачалоДня(КонецМесяца(НачПериода));
	Иначе
		НачПериода = НачалоМесяца(ДобавитьМесяц(НачПериода, знк));
		КонПериода = НачалоДня(КонецМесяца(ДобавитьМесяц(КонПериода, знк)));
	КонецЕсли;
КонецПроцедуры

&НаКлиенте
Функция   ВыбратьПериод(НачалоПериода, КонецПериода) Экспорт
	
	д = новый ДиалогРедактированияСтандартногоПериода;
	д.Период = новый СтандартныйПериод(НачалоПериода, КонецПериода);
	Если НЕ д.Редактировать() Тогда
		возврат ложь;
	КонецЕсли;
	
	НачалоПериода = д.Период.ДатаНачала;
	КонецПериода = д.Период.ДатаОкончания;
	возврат Истина;
КонецФункции
