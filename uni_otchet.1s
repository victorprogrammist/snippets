
Функция   лямбда_НазваниеДляОтчета(стру, ур_зн, ур_рекв)
	
	Если НЕ ЗначениеЗаполнено(ур_зн) Тогда
		возврат "<Пустое "+ур_рекв+">";
	КонецЕсли;
	
	Если НЕ стру.Свойство("ОтсутствуетМетод_Название") Тогда
		Попытка
			возврат стру.Контекст.НазваниеДляОтчета(ур_зн, ур_рекв);
		Исключение
			стру.Вставить("ОтсутствуетМетод_Название", Истина);
		КонецПопытки;
	КонецЕсли;
	
	возврат Строка(ур_зн);
КонецФункции

Функция   НазваниеДляОтчета(стру, ур_индекс, ур_зн, ур_рекв)
	
	преф = "";
	Для н = 1 по ур_индекс Цикл
		преф = преф + "   ";
	КонецЦикла;
	
	возврат преф + лямбда_НазваниеДляОтчета(стру, ур_зн, ур_рекв);
	
КонецФункции

Функция   лямбда_ПропуститьСтроку(стру, с_данные, ур_индекс, ур_зн)
	
	Если НЕ стру.Свойство("ОтсутствуетМетод_ПропуститьСтроку") Тогда
		
		ур_рекв = стру.Детализация.Получить(ур_индекс);
		
		Попытка
			возврат стру.Контекст.ПропуститьСтроку(стру, с_данные, ур_индекс, ур_зн);
		Исключение
			стру.Вставить("ОтсутствуетМетод_ПропуститьСтроку", Истина);
		КонецПопытки;
		
	КонецЕсли;
	
	возврат Ложь;
КонецФункции

Функция   лямбда_ЗначениеСортировки(стру, ур_зн, ур_рекв)
	
	Если НЕ стру.Свойство("ОтсутствуетМетод_ЗначениеСортировки") Тогда
		Попытка
			возврат стру.Контекст.ЗначениеСортировки(ур_зн, ур_рекв);
		Исключение
			стру.Вставить("ОтсутствуетМетод_ЗначениеСортировки", Истина);
		КонецПопытки;
	КонецЕсли;
	
	возврат ур_зн;
КонецФункции

Процедура лямбда_ЗаполнитьОбластьСтроки(стру, обл, стру_итоги, ур_рекв, ур_зн, ур_назв)
	
	Нету = Истина;
	
	Если НЕ стру.Свойство("ОтсутсвуетМетод_ЗаполнитьОбластьСтроки") Тогда
		Попытка
			стру.Контекст.ЗаполнитьОбластьСтроки(обл, стру_итоги, ур_рекв, ур_зн, ур_назв);
			Нету = Ложь;
		Исключение
			стру.Вставить("ОтсутсвуетМетод_ЗаполнитьОбластьСтроки", Истина);
		КонецПопытки;
	КонецЕсли;
	
	Если Нету Тогда
		обл.Параметры.Заполнить(стру.ЗначенияРекурсии);
		обл.Параметры.Заполнить(стру_итоги);
		обл.Параметры.Заполнить(новый Структура("Значение,Название", ур_зн, ур_назв));
	КонецЕсли;
	
КонецПроцедуры

&НаСервере
Процедура ДобавитьСтрокуВОтчет(стру, ур_индекс, ма_данные)
	
	// ур_индекс: 0..КоличествоУровнейВсего-1
	ур_рекв = стру.Детализация.Получить(ур_индекс);
	ур_зн = стру.ЗначенияРекурсии[ур_рекв];
	
	это_последний_свернутый_уровень = Ложь;
	колич_ур_без_плюса = стру.КоличествоУровнейБезПоследнегоПлюса;
	
	Если ур_индекс = 0 И колич_ур_без_плюса > 1 Тогда
		о = стру.Макет.ПолучитьОбласть("Группа1");
		
	ИначеЕсли ур_индекс = 1 и колич_ур_без_плюса > 2 Тогда
		о = стру.Макет.ПолучитьОбласть("Группа2");
		
	ИначеЕсли ур_индекс + 1 < колич_ур_без_плюса Тогда
		о = стру.Макет.ПолучитьОбласть("Группа3");
		
	ИначеЕсли ур_индекс + 1 = колич_ур_без_плюса Тогда
		о = стру.Макет.ПолучитьОбласть("Строка");
		
	Иначе
		о = стру.Макет.ПолучитьОбласть("Доки");
		это_последний_свернутый_уровень = Истина;
	КонецЕсли;
	
	ур_назв = НазваниеДляОтчета(стру, ур_индекс, ур_зн, ур_рекв);
	
	стру_итоги = ПосчитатьИтогПоСтрокам(стру, ма_данные);
	
	Если НЕ это_последний_свернутый_уровень Тогда
		НомПП = стру.НомПП + 1;
		стру.НомПП = НомПП;
		о.Параметры.Заполнить(новый Структура("НомПП", НомПП));
	КонецЕсли;
	
	лямбда_ЗаполнитьОбластьСтроки(стру, о, стру_итоги, ур_рекв, ур_зн, ур_назв);
	
	стру.ТабДок.Вывести(о, ур_индекс, ур_рекв);
	
КонецПроцедуры

&НаСервере
Процедура РекурсивноеФормированиеТабличногоДокумента(стру, ур_индекс, ма_данные)
	// ур_индекс: 0..КоличествоУровнейВсего-1
	
	ур_рекв = стру.Детализация.Получить(ур_индекс);
	ЭтоИтого = ур_рекв = "ИТОГО";
	
	Если НЕ ЭтоИтого Тогда
		инд_колонки = стру.Данные.Колонки.Индекс(стру.Данные.Колонки.Найти(ур_рекв));
	КонецЕсли;
	
	т_группы = новый ТаблицаЗначений;
	т_группы.Колонки.Добавить("Значение");
	т_группы.Колонки.Добавить("Строки");
	т_группы.Колонки.Добавить("ЗначениеСортировки");
	т_группы.Индексы.Добавить("Значение");
	
	Для каждого с_данные из ма_данные цикл
		Если ЭтоИтого Тогда
			ур_зн = "ИТОГО";
		Иначе
			ур_зн = с_данные.Получить(инд_колонки);
		КонецЕсли;
		
		фл_пропустить = лямбда_ПропуститьСтроку(стру, с_данные, ур_индекс, ур_зн);
		
		Если фл_пропустить тогда
			продолжить;
		КонецЕсли;
		
		с_группы = т_группы.Найти(ур_зн, "Значение");
		Если с_группы = Неопределено Тогда
			с_группы = т_группы.Добавить();
			с_группы.Значение = ур_зн;
			с_группы.ЗначениеСортировки = лямбда_ЗначениеСортировки(стру, ур_зн, ур_рекв);
			с_группы.Строки = новый Массив;
		КонецЕсли;
		
		с_группы.Строки.Добавить(с_данные);
	КонецЦикла;
	т_группы.Сортировать("ЗначениеСортировки");
	
	// рекурсивный вызов для каждого значения уровня
	
	количество_уровней_всего = стру.КоличествоУровнейВсего;
	колич_ур_без_плюса = стру.КоличествоУровнейБезПоследнегоПлюса;
	
	это_последний_свернутый_уровень = 
	ур_индекс = колич_ур_без_плюса
	и колич_ур_без_плюса < количество_уровней_всего;
	
	стру.ТабДок.НачатьГруппуСтрок(ур_рекв, НЕ это_последний_свернутый_уровень);
	
	Для каждого с_группы из т_группы Цикл
		стру.ЗначенияРекурсии.Вставить(ур_рекв, с_группы.Значение);
		
		ДобавитьСтрокуВОтчет(стру, ур_индекс, с_группы.Строки);
		
		Если ур_индекс+1 < количество_уровней_всего Тогда
			РекурсивноеФормированиеТабличногоДокумента(
			стру, ур_индекс+1, с_группы.Строки);
		КонецЕсли;
	КонецЦикла;
	стру.ЗначенияРекурсии.Удалить(ур_рекв);
	
	стру.ТабДок.ЗакончитьГруппуСтрок();
	
КонецПроцедуры

&НаСервере
Процедура СформироватьТаблицу(стру) Экспорт
	
	колич_ур = стру.Детализация.Количество();
	
	Если стру.ДелатьДетализациюИтого или колич_ур = 0 Тогда
		стру.Детализация.Вставить(0, "ИТОГО");
		колич_ур = колич_ур + 1;
	КонецЕсли;
	
	стру.Вставить("КоличествоУровнейВсего", колич_ур);
	ф = Ложь;
	Если стру.Свойство("ПлюсПоследний", ф) и ф = Истина Тогда
		колич_ур = колич_ур - 1;
	КонецЕсли;
	
	стру.Вставить("КоличествоУровнейБезПоследнегоПлюса", колич_ур);
	
	ма_итоги = РазделитьРеквизиты(стру.ДетализацияИтоги);
	стру.Вставить("Обработанное_ДетализацияИтоги", ма_итоги);
	
	стру.Вставить("НомПП", 0);
	стру.Вставить("ЗначенияРекурсии", новый Структура);
	
	РекурсивноеФормированиеТабличногоДокумента(стру, 0, стру.Данные);
КонецПроцедуры

&НаСервере
Функция   ИтогПоСтрокам_один_реквизит(ма_данные, рекв, ЕстьЦифры = Ложь, Тп = "сумма")
	
	перв = Истина;
	рез = 0;
	тп = НРег(тп);
	инд_колонки = -1;
	
	Для каждого с_данные из ма_данные цикл
		
		Если инд_колонки < 0 Тогда
			т = с_данные.Владелец();
			инд_колонки = т.Колонки.Индекс(т.Колонки.Найти(рекв));
		КонецЕсли;
		
		ч = с_данные.Получить(инд_колонки);
		
		Если тп = "сумма" Тогда
			
			Если ч = Неопределено или ч = null тогда
				ч = 0;
			КонецЕсли;
			
			Если ТипЗнч(ч) <> Тип("Число") Тогда
				сообщить("Рекв: "+рекв+", не число: "+ч);
			Иначе
				рез = рез + ч;
			КонецЕсли;
			
			Если ч <> 0 Тогда
				ЕстьЦифры = Истина;
			КонецЕсли;
			
		ИначеЕсли тп = "равные" Тогда
			
			Если перв Тогда
				рез = ч;
				перв = ложь;
			ИначеЕсли рез <> ч Тогда
				рез = "~~~";
				прервать;
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;
	возврат рез;
КонецФункции

&НаСервере
Функция   ПосчитатьИтогПоСтрокам(стру, ма_данные, ЕстьЦифры = Ложь)
	// ЕстьЦифры - возвращаемый признак, что в колонки были цифры отличные от нуля
	//  Даже если итог плюс на минус равен нулю, то здесь будет истина, если были
	//  отличные от нуля
	
	ма_рекв = стру.Обработанное_ДетализацияИтоги;
	
	стру_рез = новый Структура;
	
	Для каждого рекв из ма_рекв цикл
		
		рекв_уст = рекв;
		тп = "сумма";
		п = СтрНайти(рекв,":");
		Если п > 0 Тогда
			тп = Лев(рекв, п-1);
			рекв = Сред(рекв, п+1);
			рекв_уст = тп + "_" + рекв;
		КонецЕсли;
		
		ЕстьЦифры_здесь = Ложь;
		су = ИтогПоСтрокам_один_реквизит(ма_данные, рекв, ЕстьЦифры_здесь, тп);
		
		стру_рез.Вставить(рекв_уст, су);
		стру_рез.Вставить(рекв_уст+"_ЕстьЦифры", ЕстьЦифры_здесь);
		
		ЕстьЦифры = ЕстьЦифры ИЛИ ЕстьЦифры_здесь;
	КонецЦикла;
	
	возврат стру_рез;
КонецФункции

Функция   ВыбратьПомеченные(сп) Экспорт
	ма = новый Массив;
	Для каждого эл из сп цикл
		Если эл.Пометка Тогда
			ма.Добавить(эл.Значение);
		КонецЕсли;
	КонецЦикла;
	возврат ма;
КонецФункции

Процедура СделатьДетализацию(СписСГалочками, Множество) Экспорт
	
	ма = РазделитьРеквизиты(Множество);
	
	Для каждого с из ма Цикл
		Если СписСГалочками.НайтиПоЗначению(с) = Неопределено Тогда
			СписСГалочками.Добавить(с);
		КонецЕсли;
	КонецЦикла;
	
	ма_уд = новый Массив;
	Для каждого эл из СписСГалочками Цикл
		Если ма.Найти(эл.Значение) = Неопределено Тогда
			ма_уд.Добавить(эл);
		Иначе
			ма.Удалить(ма.найти(эл.Значение));
		КонецЕсли;
	КонецЦикла;
	
	Для каждого эл из ма_уд цикл
		СписСГалочками.Удалить(эл);
	КонецЦикла;
	
КонецПроцедуры

Функция   СравнитьСписки(сп, ма) Экспорт
	
	Если сп.Количество() <> ма.Количество() Тогда
		возврат Ложь;
	КонецЕсли;
	
	Для н = 0 по ма.Количество()-1 цикл
		Если сп.Получить(н).Значение <> ма.Получить(н) Тогда
			возврат Ложь;
		КонецЕсли;
	КонецЦикла;
	
	возврат Истина;
КонецФункции

&НаКлиенте
Процедура СдвигПериода(НачПериода, КонПериода, знк) Экспорт
	
	Если не ЗначениеЗаполнено(НачПериода) и не ЗначениеЗаполнено(КонПериода) Тогда
		НачПериода = НачалоМесяца(ТекущаяДата());
		КонПериода = НачалоДня(КонецМесяца(НачПериода));
		
	ИначеЕсли не ЗначениеЗаполнено(НачПериода) или не ЗначениеЗаполнено(КонПериода) Тогда
		дд = НеПуст(НачПериода, КонПериода);
		НачПериода = НачалоМесяца(ДобавитьМесяц(дд, знк));
		КонПериода = НачалоДня(КонецМесяца(НачПериода));
		
	ИначеЕсли НачалоДня(НачПериода) = НачалоДня(КонПериода) Тогда
		НачПериода = НачалоДня(НачПериода + (24 * 60 * 60 * знк));
		КонПериода = НачПериода;
		
	ИначеЕсли НачалоНедели(НачПериода) = НачалоДня(НачПериода)
		и НачалоНедели(НачПериода) = НачалоНедели(КонПериода)
		и КонецНедели(КонПериода) = КонецДня(КонПериода) Тогда
		
		НачПериода = НачалоДня(НачПериода + (24*60*60*7*знк));
		КонПериода = НачалоДня(КонецНедели(НачПериода));
		
	Иначе
		НачПериода = НачалоМесяца(ДобавитьМесяц(НачПериода, знк));
		КонПериода = НачалоДня(КонецМесяца(ДобавитьМесяц(КонПериода, знк)));
		
	КонецЕсли;
КонецПроцедуры

&НаКлиенте
Процедура ЗавершениеВыбораПериода(Период, допПарам) Экспорт
	Если Период <> Неопределено Тогда
		допПарам.Объект[допПарам.РеквНач] = Период.ДатаНачала;
		допПарам.Объект[допПарам.РеквКон] = Период.ДатаОкончания;
	КонецЕсли;
КонецПроцедуры

&НаКлиенте
Процедура ВыбратьПериод_НеМодально(Объект, РеквНач = "НачалоПериода", РеквКон = "КонецПериода") Экспорт
	
	о = новый ОписаниеОповещения(
	"ЗавершениеВыбораПериода",
	ЭтотОбъект,
	новый Структура("Объект,РеквНач,РеквКон", Объект, РеквНач, РеквКон)
	);
	
	нач = Объект[РеквНач];
	кон = Объект[РеквКон];
	
	д = новый ДиалогРедактированияСтандартногоПериода;
	д.Период = новый СтандартныйПериод(нач, кон);
	д.Показать(о);
КонецПроцедуры

&НаКлиенте
Функция   ВыбратьПериод(НачалоПериода, КонецПериода) Экспорт
	
	д = новый ДиалогРедактированияСтандартногоПериода;
	д.Период = новый СтандартныйПериод(НачалоПериода, КонецПериода);
	Если НЕ д.Редактировать() Тогда
		возврат ложь;
	КонецЕсли;
	
	НачалоПериода = д.Период.ДатаНачала;
	КонецПериода = д.Период.ДатаОкончания;
	возврат Истина;
КонецФункции

&НаСервере
Функция   СтруктураПараметров() Экспорт
	
	стру = новый Структура;
	стру.Вставить("ПлюсПоследний", Ложь); // последний будет не развернут, но по плюсику можно
	стру.Вставить("ДелатьДетализациюИтого", Истина);
	стру.Вставить("Детализация", Неопределено); // список группирования, массив
	стру.Вставить("Данные", Неопределено); // таблица с данными
	стру.Вставить("Макет", Неопределено);
	стру.Вставить("ТабДок", Неопределено);
	стру.Вставить("ДетализацияИтоги", ""); // для поиска равных "равные:ххх_рекв"
	стру.Вставить("Контекст", Неопределено);
	
	возврат стру;
КонецФункции

&НаСервере
Функция   СтруктураПараметровПоУмолчанию(Объект, Данные) Экспорт
	
	ма_детал = ВыбратьПомеченные(Объект.Детализация);
	
	стру = СтруктураПараметров();
	стру.ТабДок = новый ТабличныйДокумент;
	стру.Макет = Объект.РеквизитФормыВЗначение("Объект").ПолучитьМакет("Макет");
	
	Если ма_детал.Найти("Документ") = Неопределено
		И НЕ Объект.БезАвтоматическогоРазворотаПоДокументам Тогда
		
		ма_детал.Добавить("Документ");
		стру.ПлюсПоследний = Истина;
	КонецЕсли;
	
	стру.Детализация = ма_детал;
	стру.Данные = Данные;
	стру.Контекст = Объект;
	возврат стру;
КонецФункции
